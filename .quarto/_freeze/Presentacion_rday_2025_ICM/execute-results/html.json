{
  "hash": "399752bbec02bb78376daa13cb756a48",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Presentación R Day 2025 — Martingalas inductivas conformales\"\nsubtitle: \"ICM — Inductive Conformal Martingales\"\nauthor: \"Cristhian Quiroz Castaño\"\ndate: today\nlang: es\nformat:\n  revealjs:\n    theme: theme.scss\n    transition: fade\n    background-transition: fade\n    highlight-style: ayu-mirage\n    slide-number: true\n    auto-animate: true\ncode-link: true\nexecute:\n  echo: true\n  warning: false\n  cache: false\n  freeze: auto\ntoc: false\neditor: visual\n---\n\n# Agenda\n\n<br/>\n\n::: incremental\n-   Objetivo y motivación\n-   Puntos de cambio\n-   Idea general de ICM\n-   Implementación en R\n-   Resultados de experimentos\n-   Conclusiones\n:::\n\n# Objetivo\n\n<br/>\n\n::: incremental\n-   Introducir las martingalas inductivas conformales (ICM).\n-   Presentar la implementación en R de los métodos\n-   Presentar los experimentos realizados y sus respectivos resultados.\n:::\n\n# Motivación\n\n<br/>\n\n::: incremental\n-   Detección de puntos de cambio es un problema transversal a muchas áreas.\n-   ICM presenta un método no parámetrico novedoso.\n-   Aumentar el catálogo de métodos ofrecidos por la librería tidychangepoint.\n:::\n\n# Puntos de cambio\n\nEl problema de puntos de cambio se formula de la siguiente manera:\n\n-   Sea $(z_1, z_2, \\dots, z_n, \\dots)$ un conjunto de observaciones.\n-   Suponemos que existe un índice $\\theta$ tal que $z_1, z_2, \\dots, z_{\\theta-1} \\sim f_0(z)$ y $z_{\\theta}, z_{\\theta+1}, \\dots \\sim f_1(z)$.\n-   Ese $\\theta$ es lo que consideramos el punto de cambio.\n-   Nuestro objetivo es identificar $\\theta$ tan pronto como sea posible.\n\n# Idea general (ICM)\n\n<br/>\n\n```{=html}\n<style>\n.arrow-flow {\n  display: flex;\n  gap: 0.6rem;\n  flex-wrap: wrap;\n  justify-content: center;\n  margin-top: 1rem;\n}\n.arrow-flow .arrow {\n  background: #1c4f87;\n  color: #fff;\n  padding: 0.7rem 1.6rem;\n  font-weight: 600;\n  text-align: center;\n  min-width: 12rem;\n  clip-path: polygon(0 0, calc(100% - 1.2rem) 0, 100% 50%, calc(100% - 1.2rem) 100%, 0 100%, 1.2rem 50%);\n  box-shadow: 0 2px 6px rgba(0,0,0,0.25);\n}\n</style>\n```\n\n::::::::: arrow-flow\n::: arrow\nObservaciones intercambiables\n:::\n\n::: arrow\nMedida de no conformidad\n:::\n\n::: arrow\nP-valores\n:::\n\n::: arrow\nFunción de apuesta\n:::\n\n::: arrow\nMartingala\n:::\n\n::: arrow\nAlarma\n:::\n:::::::::\n\n## Medida de no conformidad & P-valor\n\n::: goal\nDefinimos la medida de no conformidad como:\n:::\n\n$$\n\\alpha_i = \\mathcal{A}(z_{i}, \\mathcal{Z})\n$$\n\n::: {style=\"height:1.6rem;\"}\n:::\n\n::: goal\nCon esta medida construimos el $p$-valor de la siguiente manera:\n:::\n\n$$\np_t = \\frac{\\lvert\\{i \\le t : \\alpha_i > \\alpha_t\\}\\rvert + U\\,\\lvert\\{i \\le t : \\alpha_i = \\alpha_t\\}\\rvert}{t}\n$$\n\n## Función de apuesta\n\n::: goal\nNecesitamos un mecanismo que nos permita \"hacer apuestas\":\n:::\n\n$$\ng(p): [0,1] \\longrightarrow \\mathbb{R}^+\n$$\n\n::: goal\nEsta función debe satisfacer la siguiente propiedad:\n:::\n\n$$\n\\int_{0}^{1} g(p)\\,dp = 1\n$$\n\n## Martingala\n\n::: goal\nLa martingala se construye de la siguiente manera:\n:::\n\n$$\nS_0 = 1, \\qquad S_n = \\prod_{i=1}^{n} g(p_i)\n$$\n\n::: goal\nLa construcción anterior garantiza que se cumple la condición de martingala:\n:::\n\n$$\n\\mathbb{E}\\!\\left[S_{n+1} \\mid S_0, S_1, \\dots, S_n\\right] = S_n\n$$\n\n## Intercambiabilidad\n\n::: goal\nAsumiremos que las observaciones son intercambiables, es decir:\n:::\n\n<br/>\n\n$$\n(Z_1, Z_2, \\dots, Z_n) \\stackrel{d}{=} (Z_{\\pi(1)}, Z_{\\pi(2)}, \\dots, Z_{\\pi(n)})\n$$\n\n<br/>\n\nEsta suposición garantiza que: $$\n\\{p_i\\}_{i=1}^{n} \\sim Unif(0,1)\n$$\n\n## Detección de puntos de cambio.\n\n::: goal\nQueremos determinar si ocurre un cambio y definimos el siguiente mecanismo de detección:\n:::\n\n$$\n\\tau = \\inf\\{i \\mid S_i \\ge h\\}\n$$\n\n::: goal\nComo la construcción es una martingala, se cumple la desigualdad de Ville, lo que entrega un umbral con garantías para las alarmas:\n:::\n\n$$\n\\mathbb{P}\\!\\left(\\exists n \\mid S_n \\ge \\frac{1}{\\alpha}\\right) \\le \\alpha\n$$\n\n# Implementación en R\n\n-   Medidas de no conformidad\n-   Función de apuesta\n-   ICM\n\n## Medida de no conformidad\n\n`Desviación absoluta a la mediana`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nNon_conformity_MAD <- function(xi, training_set, K=NULL,...){\n  med <- median(training_set)\n  mad_val <- median(abs(training_set - med))\n  score <- abs(xi - med) / (mad_val + 1e-8)\n  return(score)\n}\n```\n:::\n\n\n`Rango intercuartílico`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nNon_conformity_IQR <- function(xi, training_set, k=NULL,...){\n  qs <- as.numeric(quantile(training_set, \n              probs = c(0.25, 0.5, 0.75), type = 8, \n              names = FALSE))\n  width <- max(qs[3] - qs[1], 1e-8)\n  score <- abs(xi - qs[2]) / width\n  return(score)\n}\n```\n:::\n\n\n## Medida de no conformidad\n\n`Desviación absoluta a la mediana`\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"4\"}\nNon_conformity_MAD <- function(xi, training_set, K=NULL,...){\n  med <- median(training_set)\n  mad_val <- median(abs(training_set - med))\n  score <- abs(xi - med) / (mad_val + 1e-8)\n  return(score)\n}\n```\n:::\n\n\n`Rango intercuartílico`\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"6\"}\nNon_conformity_IQR <- function(xi, training_set, k=NULL,...){\n  qs <- as.numeric(quantile(training_set, \n              probs = c(0.25, 0.5, 0.75), type = 8, \n              names = FALSE))\n  width <- max(qs[3] - qs[1], 1e-8)\n  score <- abs(xi - qs[2]) / width\n  return(score)\n}\n```\n:::\n\n\n## Funciones de apuesta\n\n<br/>\n\nFirmas de las funciones de apuesta implementadas.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nConstant_BF <- function(p_values, new_p, i, ...)\nMixture_BF <- function(p_values, new_p, i, ...)\nKernel_BF <- function(p_values, new_p, i, ...)\nhistogram_BF <- function(p_values, new_p, num_bins = 2L, ...)\n```\n:::\n\n\nR provee muchas facilidades para implementar funciones de apuesta; un ejemplo a resaltar es `stats::density` para la función de kernel.\n\n## ICM\n\n::: small\nDetección de un punto de cambio\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nICM <- function(training_set, stream_data,\n                non_conformity_measure,\n                betting_function,\n                th = 1, params_bf = list(), ...)\n```\n:::\n\n\n::: small\nDetección de múltiples puntos de cambio\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nICM_multi <- function(training_set, stream_data,\n                      non_conformity_measure,\n                      betting_function,\n                      th = 1, params_bf = list(), ...)\n```\n:::\n\n\n::: small\nDetección de múltiples puntos de cambio con reentrenamiento\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nICM_multi_adaptive <- function(stream_data,\n                               non_conformity_measure,\n                               betting_function,\n                               training_set = NULL, training_size = NULL,\n                               m_retrain = NULL, guard_band = 0,\n                               ...)\n```\n:::\n\n\n## ICM\n\n::: small\nDetección de un punto de cambio\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"2-3\"}\nICM <- function(training_set, stream_data,\n                non_conformity_measure,\n                betting_function,\n                th = 1, params_bf = list(), ...)\n```\n:::\n\n\n::: small\nDetección de múltiples puntos de cambio\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"2-3\"}\nICM_multi <- function(training_set, stream_data,\n                      non_conformity_measure,\n                      betting_function,\n                      th = 1, params_bf = list(), ...)\n```\n:::\n\n\n::: small\nDetección de múltiples puntos de cambio con reentrenamiento\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"2-3\"}\nICM_multi_adaptive <- function(stream_data,\n                               non_conformity_measure,\n                               betting_function,\n                               training_set = NULL, training_size = NULL,\n                               m_retrain = NULL, guard_band = 0,\n                               ...)\n```\n:::\n\n\n## Experimentos y resultados\n\nTodos los experimentos descritos en esta sección aprovechan las características de los paquetes `future`, `purrr`, `tidyr`, `dplyr` y `ggplot2`. <br/>\n\n::: center\n![Librerias R](Presentacion_rday_2025_ICM_files/figure-revealjs/libreriashexalogor.png){width=\"55%\"}\n:::\n\n## Sensibilidad al umbral\n\n-   Conjunto de entrenamiento $\\mathcal{Z}$ de tamaño $m = 200$.\n-   Observaciones de entrenamiento y primer segmento $z_1, \\dots, z_{\\theta-1}$ con distribución $\\mathcal{N}(0, 1)$.\n-   Segmento posterior al cambio $z_{\\theta}, z_{\\theta+1}, \\dots$ con distribución $\\mathcal{N}(\\mu_1, 1)$.\n-   Métricas: probabilidad de falsa alarma $\\mathbb{P}(\\tau \\le \\theta)$ y retraso medio $\\mathbb{E}(\\tau - \\theta \\mid \\tau > \\theta)$.\n\n## Sensibilidad KNN\n\n## Precisión de los métodos múltiples\n\n# Conclusiones\n\nplaceholder\n\n## Referencias\n\n-   Volkhonskiy, D., Burnaev, E., Nouretdinov, I., Gammerman, A., Vovk, V. (2017). *Inductive Conformal Martingales for Change-Point Detection*. En **Conformal and Probabilistic Prediction and Applications**, PMLR 60, 1--22.\n-   Kato, Y., Tax, D.M.J., Loog, M. (2023). *A Review of Nonconformity Measures for Conformal Prediction in Regression*. En **Conformal and Probabilistic Prediction with Applications**, PMLR 204, 1--15.\n-   Eliades, C., Papadopoulos, H. (2020). *A Histogram based Betting Function for Conformal Martingales*. En **Conformal and Probabilistic Prediction and Applications**, PMLR 128, 1--14.\n\n## Referencias (cont.)\n\n-   Eliades, C., Papadopoulos, H. (2021). *Using Inductive Conformal Martingales for Addressing Concept Drift in Data Stream Classification*. En **Conformal and Probabilistic Prediction and Applications**, PMLR 152, 1--20.\n-   Wickham, H., Henry, L. (2025). *purrr: Functional Programming Tools*. R package version 1.1.0, <https://purrr.tidyverse.org/>.\n-   Wickham, H., Francois, R., Henry, L., Muller, K., Vaughan, D. (2025). *dplyr: A Grammar of Data Manipulation*. R package version 1.1.4, <https://dplyr.tidyverse.org/>.\n\n## Referencias (cont.)\n\n-   Wickham, H., Vaughan, D., Girlich, M. (2025). *tidyr: Tidy Messy Data*. R package version 1.3.1, <https://tidyr.tidyverse.org/>.\n-   Wickham, H. (2016). *ggplot2: Elegant Graphics for Data Analysis*. Springer-Verlag New York.\n-   Bengtsson, H. (2021). *A Unifying Framework for Parallel and Distributed Processing in R using Futures*. **The R Journal**, 13(2), 208--227. <https://doi.org/10.32614/RJ-2021-048>.\n\n# Gracias\n\n-   Correo: cquirozc1\\@eafit.edu.co\n-   GitHub: https://github.com/CQuiorzC",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}