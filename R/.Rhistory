t_scen <- Sys.time()
ncm_tbl <- tibble(
ncm_fun  = list(Non_conformity_KNN,
make_ncm_LR(mu1_s), Non_conformity_MAD, Non_conformity_IQR),
ncm_lbl  = c("KNN", "LR", "MAD", "IQR"),
needs_k  = c(TRUE,  FALSE, FALSE, FALSE)
)
bet_tbl <- tibble(
bet_fun   = list(Constant_BF, Mixture_BF, kde_bf_fixed, histogram_betting_function),
bet_lbl   = c("Constant BF", "Mixture BF", "Precomputed KDE BF", "Histogram BF"),
params_bf = list(
list(),
list(),
list(),
list(num_bins = 2)
)
)
icm_res <- expand_grid(ncm_tbl, bet_tbl) |>
pmap(function(ncm_fun, ncm_lbl, needs_k,
bet_fun, bet_lbl, params_bf) {
k_val <- if (needs_k) k_par else NULL
out_icm <- montecarlo_ICM(
n_sim        = n_sim,
h_vals       = h_vals,
theta_stream = theta_s,
mu1          = mu1_s,
m            = m,
ncm_fun      = ncm_fun,
bet_fun      = bet_fun,
k            = k_val,
params_bf    = params_bf,
n_stream     = 1000
)
sum_icm <- out_icm$summary |>
mutate(Method = paste(ncm_lbl, bet_lbl, "+ ICM"))
tau_icm <- out_icm$taus |>
mutate(Method = paste(ncm_lbl, bet_lbl, "+ ICM"),
ncm = ncm_lbl, bf = bet_lbl)
list(summary = sum_icm,
taus    = tau_icm)
})
icm_res_summary <- bind_rows(purrr::map(icm_res, "summary"))
icm_res_taus    <- bind_rows(purrr::map(icm_res, "taus"))
combined_summary <- bind_rows(icm_res_summary) %>%
mutate(
theta_stream = factor(theta_stream, levels = theta_vals),
mu1          = factor(mu1,        levels = mu1_vals),
scenario_id  = paste0("θ=", theta_s, "_μ1=", mu1_s)
)
combined_taus <- icm_res_taus %>%
bind_rows(or_taus) %>%
mutate(
theta_stream = factor(theta_s, levels = theta_vals),
mu1          = factor(mu1_s,   levels = mu1_vals),
scenario_id  = paste0("θ=", theta_s, "_μ1=", mu1_s)
)
all_results[[paste0("θ=", theta_s, "_μ1=", mu1_s)]]  <- combined_summary
all_taus_tbl[[paste0("θ=", theta_s, "_μ1=", mu1_s)]] <- combined_taus
secs <- as.numeric(difftime(Sys.time(), t_scen, units = "secs"))
cat(sprintf(" Escenario θ=%s, μ1=%s listo en %.1f s (%.1f min)\n",
theta_s, mu1_s, secs, secs/60))
}
}
library(tidyr)
library(dplyr)
library(purrr)
library(future)
library(future.apply)
workers_use <- max(1, parallel::detectCores(logical = FALSE) - 1)
plan(multisession, workers = workers_use)
source("Basics/Non_conformity_measures.R")
source("Basics/Betting_functions.R")
source("Basics/Detectors_ICM.R")
source("Basics/Helpers.R")
source("Basics/Montecarlo_function.R")
kde_bf_fixed <- readRDS("Data/kde_bf_fixed.rds")
make_ncm_LR <- function(mu_shift) {
function(xi, training_set, ...) {
Non_conformity_LNR(xi, training_set, mu_r = mu_shift)
}
}
theta_vals <- c(100, 200)
mu1_vals   <- c(1, 1.5, 2)
h_vals     <- seq(1, 9, 0.5)
n_sim      <- 1
m          <- 200
k_par      <- 7
t_total <- Sys.time()
all_results  <- list()
all_taus_tbl <- list()
for (theta_s in theta_vals) {
for (mu1_s in mu1_vals) {
t_scen <- Sys.time()
ncm_tbl <- tibble(
ncm_fun  = list(Non_conformity_KNN,
make_ncm_LR(mu1_s), Non_conformity_MAD, Non_conformity_IQR),
ncm_lbl  = c("KNN", "LR", "MAD", "IQR"),
needs_k  = c(TRUE,  FALSE, FALSE, FALSE)
)
bet_tbl <- tibble(
bet_fun   = list(Constant_BF, Mixture_BF, kde_bf_fixed, histogram_betting_function),
bet_lbl   = c("Constant BF", "Mixture BF", "Precomputed KDE BF", "Histogram BF"),
params_bf = list(
list(),
list(),
list(),
list(num_bins = 2)
)
)
icm_res <- expand_grid(ncm_tbl, bet_tbl) |>
pmap(function(ncm_fun, ncm_lbl, needs_k,
bet_fun, bet_lbl, params_bf) {
k_val <- if (needs_k) k_par else NULL
out_icm <- montecarlo_ICM(
n_sim        = n_sim,
h_vals       = h_vals,
theta_stream = theta_s,
mu1          = mu1_s,
m            = m,
ncm_fun      = ncm_fun,
bet_fun      = bet_fun,
k            = k_val,
params_bf    = params_bf,
n_stream     = 1000
)
sum_icm <- out_icm$summary |>
mutate(Method = paste(ncm_lbl, bet_lbl, "+ ICM"))
tau_icm <- out_icm$taus |>
mutate(Method = paste(ncm_lbl, bet_lbl, "+ ICM"),
ncm = ncm_lbl, bf = bet_lbl)
list(summary = sum_icm,
taus    = tau_icm)
})
icm_res_summary <- bind_rows(purrr::map(icm_res, "summary"))
icm_res_taus    <- bind_rows(purrr::map(icm_res, "taus"))
combined_summary <- bind_rows(icm_res_summary) %>%
mutate(
theta_stream = factor(theta_stream, levels = theta_vals),
mu1          = factor(mu1,        levels = mu1_vals),
scenario_id  = paste0("θ=", theta_s, "_μ1=", mu1_s)
)
combined_taus <- icm_res_taus %>%
bind_rows() %>%
mutate(
theta_stream = factor(theta_s, levels = theta_vals),
mu1          = factor(mu1_s,   levels = mu1_vals),
scenario_id  = paste0("θ=", theta_s, "_μ1=", mu1_s)
)
all_results[[paste0("θ=", theta_s, "_μ1=", mu1_s)]]  <- combined_summary
all_taus_tbl[[paste0("θ=", theta_s, "_μ1=", mu1_s)]] <- combined_taus
secs <- as.numeric(difftime(Sys.time(), t_scen, units = "secs"))
cat(sprintf(" Escenario θ=%s, μ1=%s listo en %.1f s (%.1f min)\n",
theta_s, mu1_s, secs, secs/60))
}
}
df_all_methods <- bind_rows(all_results,  .id = "scenario_key")
df_all_taus    <- bind_rows(all_taus_tbl, .id = "scenario_key")
saveRDS(df_all_methods, file = "Data/thsensitivity.rds")
saveRDS(df_all_taus,    file = "Data/alarmsofsens.rds")
cat(" Done all iterations\n")
secs_total <- as.numeric(difftime(Sys.time(), t_total, units = "secs"))
cat(sprintf("Tiempo total: %.1f s (%.1f min)\n", secs_total, secs_total/60))
plan(sequential)
library(tidyr)
library(dplyr)
library(purrr)
library(ggplot2)
library(future)
library(future.apply)
library(forcats)
workers_use <- max(1, parallel::detectCores(logical = FALSE) - 1)
plan(multisession, workers = workers_use)
source("Basics/Non_conformity_measures.R")
source("Basics/Betting_functions.R")
source("Basics/Detectors_ICM.R")
source("Basics/Helpers.R")
source("Basics/Montecarlo_function.R")
kde_bf_fixed <- readRDS("Data/kde_bf_fixed.rds")
theta_vals <- c(100, 200)
mu1_vals   <- c(1, 1.5, 2)
h_vals     <- seq(1, 9, 0.5)
n_sim      <- 1
m          <- 200
n_stream   <- 5000
K_grid     <- c(1, 7, 25, 50, 100, 150, 200)
bet_tbl <- tibble(
bet_fun   = list(Constant_BF, Mixture_BF, kde_bf_fixed, histogram_betting_function),
bet_lbl   = c("Constant BF", "Mixture BF", "Precomputed KDE BF", "Histogram BF"),
params_bf = list(
list(),
list(),
list(),
list(num_bins = 2)
)
)
t_total <- Sys.time()
all_results  <- list()
all_taus_tbl <- list()
for (theta_s in theta_vals) {
for (mu1_s in mu1_vals) {
t_scen <- Sys.time()
message(sprintf("▶ Case θ=%s, μ1=%s ...", theta_s, mu1_s))
make_ncm_LR <- function(mu_shift) {
function(xi, training_set, ...) {
Non_conformity_LNR(xi, training_set, mu_r = mu_shift)
}
}
ncm_tbl <- tibble(
ncm_fun = list(
Non_conformity_KNN,   # KNN
Non_conformity_MAD,   # MAD
Non_conformity_IQR,   # IQR
make_ncm_LR(mu1_s)    # LR
),
ncm_lbl = c("KNN", "MAD", "IQR", "LR"),
needs_k = c(TRUE, FALSE, FALSE, FALSE)
)
res_list <- expand_grid(ncm_tbl, bet_tbl) |>
pmap(function(ncm_fun, ncm_lbl, needs_k, bet_fun, bet_lbl, params_bf) {
K_vec <- if (needs_k) K_grid else NA_integer_
map(K_vec, function(K_try) {
out_icm <- montecarlo_ICM(
n_sim        = n_sim,
h_vals       = h_vals,
theta_stream = theta_s,
mu1          = mu1_s,
m            = m,
ncm_fun      = ncm_fun,
bet_fun      = bet_fun,
k            = if (needs_k) K_try else NULL,
params_bf    = params_bf,
n_stream     = n_stream
)
sum_icm <- out_icm$summary |>
mutate(Method = paste(ncm_lbl, bet_lbl, "+ ICM"),
ncm = ncm_lbl, bf = bet_lbl, K = if (needs_k) K_try else NA_integer_)
tau_icm <- out_icm$taus |>
mutate(Method = paste(ncm_lbl, bet_lbl, "+ ICM"),
ncm = ncm_lbl, bf = bet_lbl, K = if (needs_k) K_try else NA_integer_)
list(summary = sum_icm, taus = tau_icm)
}) |>
{\(.x) list(summary = bind_rows(map(.x, "summary")),
taus    = bind_rows(map(.x, "taus")))}()
})
scen_summary <- bind_rows(purrr::map(res_list, "summary")) |>
mutate(
theta_stream = factor(theta_s, levels = theta_vals),
mu1          = factor(mu1_s,   levels = mu1_vals),
scenario_id  = paste0("θ=", theta_s, "_μ1=", mu1_s)
)
scen_taus <- bind_rows(purrr::map(res_list, "taus")) |>
mutate(
theta_stream = factor(theta_s, levels = theta_vals),
mu1          = factor(mu1_s,   levels = mu1_vals),
scenario_id  = paste0("θ=", theta_s, "_μ1=", mu1_s)
)
key <- paste0("θ=", theta_s, "_μ1=", mu1_s)
all_results[[key]]  <- scen_summary
all_taus_tbl[[key]] <- scen_taus
secs <- as.numeric(difftime(Sys.time(), t_scen, units = "secs"))
message(sprintf("✓ Escenario θ=%s, μ1=%s listo en %.1f s (%.1f min)",
theta_s, mu1_s, secs, secs/60))
}
}
library(tidyr)
library(dplyr)
library(purrr)
library(ggplot2)
library(future)
library(future.apply)
library(forcats)
workers_use <- max(1, parallel::detectCores(logical = FALSE) - 1)
plan(multisession, workers = workers_use)
source("Basics/Non_conformity_measures.R")
source("Basics/Betting_functions.R")
source("Basics/Detectors_ICM.R")
source("Basics/Helpers.R")
source("Basics/Montecarlo_function.R")
kde_bf_fixed <- readRDS("Data/kde_bf_fixed.rds")
theta_vals <- c(100, 200)
mu1_vals   <- c(1, 1.5, 2)
h_vals     <- seq(1, 9, 0.5)
n_sim      <- 1
m          <- 200
n_stream   <- 1000
K_grid     <- c(1, 7, 25, 50, 100, 150, 200)
bet_tbl <- tibble(
bet_fun   = list(Constant_BF, Mixture_BF, kde_bf_fixed, histogram_betting_function),
bet_lbl   = c("Constant BF", "Mixture BF", "Precomputed KDE BF", "Histogram BF"),
params_bf = list(
list(),
list(),
list(),
list(num_bins = 2)
)
)
t_total <- Sys.time()
all_results  <- list()
all_taus_tbl <- list()
for (theta_s in theta_vals) {
for (mu1_s in mu1_vals) {
t_scen <- Sys.time()
message(sprintf("▶ Case θ=%s, μ1=%s ...", theta_s, mu1_s))
make_ncm_LR <- function(mu_shift) {
function(xi, training_set, ...) {
Non_conformity_LNR(xi, training_set, mu_r = mu_shift)
}
}
ncm_tbl <- tibble(
ncm_fun = list(
Non_conformity_KNN,   # KNN
Non_conformity_MAD,   # MAD
Non_conformity_IQR,   # IQR
make_ncm_LR(mu1_s)    # LR
),
ncm_lbl = c("KNN", "MAD", "IQR", "LR"),
needs_k = c(TRUE, FALSE, FALSE, FALSE)
)
res_list <- expand_grid(ncm_tbl, bet_tbl) |>
pmap(function(ncm_fun, ncm_lbl, needs_k, bet_fun, bet_lbl, params_bf) {
K_vec <- if (needs_k) K_grid else NA_integer_
map(K_vec, function(K_try) {
out_icm <- montecarlo_ICM(
n_sim        = n_sim,
h_vals       = h_vals,
theta_stream = theta_s,
mu1          = mu1_s,
m            = m,
ncm_fun      = ncm_fun,
bet_fun      = bet_fun,
k            = if (needs_k) K_try else NULL,
params_bf    = params_bf,
n_stream     = n_stream
)
sum_icm <- out_icm$summary |>
mutate(Method = paste(ncm_lbl, bet_lbl, "+ ICM"),
ncm = ncm_lbl, bf = bet_lbl, K = if (needs_k) K_try else NA_integer_)
tau_icm <- out_icm$taus |>
mutate(Method = paste(ncm_lbl, bet_lbl, "+ ICM"),
ncm = ncm_lbl, bf = bet_lbl, K = if (needs_k) K_try else NA_integer_)
list(summary = sum_icm, taus = tau_icm)
}) |>
{\(.x) list(summary = bind_rows(map(.x, "summary")),
taus    = bind_rows(map(.x, "taus")))}()
})
scen_summary <- bind_rows(purrr::map(res_list, "summary")) |>
mutate(
theta_stream = factor(theta_s, levels = theta_vals),
mu1          = factor(mu1_s,   levels = mu1_vals),
scenario_id  = paste0("θ=", theta_s, "_μ1=", mu1_s)
)
scen_taus <- bind_rows(purrr::map(res_list, "taus")) |>
mutate(
theta_stream = factor(theta_s, levels = theta_vals),
mu1          = factor(mu1_s,   levels = mu1_vals),
scenario_id  = paste0("θ=", theta_s, "_μ1=", mu1_s)
)
key <- paste0("θ=", theta_s, "_μ1=", mu1_s)
all_results[[key]]  <- scen_summary
all_taus_tbl[[key]] <- scen_taus
secs <- as.numeric(difftime(Sys.time(), t_scen, units = "secs"))
message(sprintf("✓ Escenario θ=%s, μ1=%s listo en %.1f s (%.1f min)",
theta_s, mu1_s, secs, secs/60))
}
}
df_ncm_compare_summary <- bind_rows(all_results,  .id = "scenario_key")
df_ncm_compare_taus    <- bind_rows(all_taus_tbl, .id = "scenario_key")
dir.create("data", showWarnings = FALSE, recursive = TRUE)
saveRDS(df_ncm_compare_summary, file = "Data/KNNSENS.rds")
saveRDS(df_ncm_compare_taus,    file = "Data/KNNSENS_alarms.rds")
secs_total <- as.numeric(difftime(Sys.time(), t_total, units = "secs"))
message(sprintf("⏱ Total time: %.1f s (%.1f min)", secs_total, secs_total/60))
plan(sequential)
library(tidyr)
library(dplyr)
library(purrr)
library(future)
library(future.apply)
workers_use <- max(1, parallel::detectCores(logical = FALSE) - 1)
plan(multisession, workers = workers_use)
source("Basics/Non_conformity_measures.R")
source("Basics/Betting_functions.R")
source("Basics/Detectors_ICM.R")
source("Basics/Helpers.R")
source("Basics/Montecarlo_function.R")
kde_bf_fixed <- readRDS("data/kde_bf_fixed.rds")
make_ncm_LR <- function(mu_shift) {
function(xi, training_set, ...) {
Non_conformity_LNR(xi, training_set, mu_r = mu_shift)
}
}
scenarios_multi <- tribble(
~scenario_id,            ~theta_vec,          ~mu_levels,
"S1: 2 changes up/down", c(500, 1300),         c(0, 1.5, 0),
"S2: 3 changes up-up",   c(300, 1000, 1700),    c(0, 1.0, 2.0, 3.0)
)
h_vals   <- seq(1, 6, 0.5)
n_sim    <- 1
m        <- 200
n_stream <- 2000
k_par    <- 7
window_mode <- "frac"
window_abs  <- Inf
window_frac <- 1
m_retrain  <- m
guard_band <- 20
t_total <- Sys.time()
all_summary    <- list()
all_perchange  <- list()
all_alarms     <- list()
for (s in seq_len(nrow(scenarios_multi))) {
sc <- scenarios_multi[s,]
mu_levels_sc <- sc$mu_levels[[1]]
jumps <- abs(diff(mu_levels_sc))
delta_sc <- if (length(jumps)) median(jumps) else 1.0
ncm_tbl <- tibble(
ncm_fun  = list(
Non_conformity_KNN,
make_ncm_LR(delta_sc),
Non_conformity_MAD,
Non_conformity_IQR
),
ncm_lbl  = c("KNN", "LR", "MAD", "IQR"),
needs_k  = c(TRUE, FALSE, FALSE, FALSE)
)
bet_tbl <- tibble(
bet_fun   = list(Constant_BF, Mixture_BF, kde_bf_fixed, histogram_betting_function),
bet_lbl   = c("Constant BF", "Mixture BF", "Precomputed KDE BF", "Histogram BF"),
params_bf = list(list(), list(), list(), list(num_bins = 2))
)
icm_multi_res <- expand_grid(ncm_tbl, bet_tbl) |>
pmap(function(ncm_fun, ncm_lbl, needs_k, bet_fun, bet_lbl, params_bf) {
params_bf$bf_name  <- bet_lbl
params_bf$ncm_name <- ncm_lbl
k_val <- if (needs_k) k_par else NULL
out_m <- montecarlo_ICM_MULTI(
n_sim      = n_sim,
h_vals     = h_vals,
m          = m,
n_stream   = n_stream,
theta_vec  = sc$theta_vec[[1]],
mu_levels  = sc$mu_levels[[1]],
ncm_fun    = ncm_fun,
bet_fun    = bet_fun,
params_bf  = params_bf,
k          = k_val,
window_mode = window_mode,
window_abs  = window_abs,
window_frac = window_frac
)
sum_m <- out_m$summary |>
mutate(Method = paste(ncm_lbl, bet_lbl, "+ ICM-multi"),
ncm = ncm_lbl, bf = bet_lbl,
scenario_id = sc$scenario_id)
per_m <- out_m$per_change |>
mutate(Method = paste(ncm_lbl, bet_lbl, "+ ICM-multi"),
ncm = ncm_lbl, bf = bet_lbl,
scenario_id = sc$scenario_id)
alm_m <- out_m$alarms |>
mutate(Method = paste(ncm_lbl, bet_lbl, "+ ICM-multi"),
ncm = ncm_lbl, bf = bet_lbl,
scenario_id = sc$scenario_id)
out_a <- montecarlo_ICM_MULTI_ADAPTIVE(
n_sim      = n_sim,
h_vals     = h_vals,
m          = m,
n_stream   = n_stream,
theta_vec  = sc$theta_vec[[1]],
mu_levels  = sc$mu_levels[[1]],
ncm_fun    = ncm_fun,
bet_fun    = bet_fun,
params_bf  = params_bf,
k          = k_val,
m_retrain  = m_retrain,
guard_band = guard_band,
window_mode = window_mode,
window_abs  = window_abs,
window_frac = window_frac
)
sum_a <- out_a$summary |>
mutate(Method = paste(ncm_lbl, bet_lbl, "+ ICM-multi-adaptive"),
ncm = ncm_lbl, bf = bet_lbl,
scenario_id = sc$scenario_id)
per_a <- out_a$per_change |>
mutate(Method = paste(ncm_lbl, bet_lbl, "+ ICM-multi-adaptive"),
ncm = ncm_lbl, bf = bet_lbl,
scenario_id = sc$scenario_id)
alm_a <- out_a$alarms |>
mutate(Method = paste(ncm_lbl, bet_lbl, "+ ICM-multi-adaptive"),
ncm = ncm_lbl, bf = bet_lbl,
scenario_id = sc$scenario_id)
list(
summary    = bind_rows(sum_m, sum_a),
per_change = bind_rows(per_m, per_a),
alarms     = bind_rows(alm_m, alm_a)
)
})
all_summary[[sc$scenario_id]]   <- bind_rows(map(icm_multi_res, "summary"))
all_perchange[[sc$scenario_id]] <- bind_rows(map(icm_multi_res, "per_change"))
all_alarms[[sc$scenario_id]]    <- bind_rows(map(icm_multi_res, "alarms"))
secs <- as.numeric(difftime(Sys.time(), t_total, units = "secs"))
cat(sprintf("✅ %s listo. Acumulado: %.1f s (%.1f min)\n",
sc$scenario_id, secs, secs/60))
}
df_multi_summary   <- bind_rows(all_summary,   .id = "scenario_group")
df_multi_perchange <- bind_rows(all_perchange, .id = "scenario_group")
df_multi_alarms    <- bind_rows(all_alarms,    .id = "scenario_group")
saveRDS(df_multi_summary,   file = "Data/multi_summary.rds")
saveRDS(df_multi_perchange, file = "Data/multi_perchange.rds")
saveRDS(df_multi_alarms,    file = "Data/multi_alarms.rds.rds")
cat("Done\n")
plan(sequential)
